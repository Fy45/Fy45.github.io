[{"title":"Ethereum Smart Contract 1st try..><","url":"/2019/07/16/2019-07-16/","content":"\n# 跳坑\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<center> -学术7-y.","tags":["Project"],"categories":["KTH"]},{"title":"项目终于走出了迷雾","url":"/2019/06/26/2019-06-26/","content":"\n> 初识 bitshares 是因为公司所用的区块链是基于bitshares搭建的  \n>\n> 为了毕设的成功推进，这也是必经之路了，幸好测试网络的使用给最终啃下来了 下面是一些自己的小心得和记录\n>\n> 可一定得毕业啊（未来焦虑患者\n>\n> 尝试了一下public testnet\n>\n> 用户名：yfan-testnet\n>\n> 密码：P5JUW3US1SqhHZ4RAqt7PrhqqEfN2kotnrh7MS9HMbqA9\n\n# 4对密钥对以及地址/最终用户yfan\n\n> w1 w2 w3 admin\n\n[{\"private_key\":\"5JjzogP6V1TciYQHthBLPnmj5cyrYLfwfoDeY6rpG4mcNUd7hDq\",\"public_key\":\"BTS6WqFcNmb8DA8SG2HJDL23TzSKk67HrCf6qTeqXhbCcohi11epm\",\"address\":\"BTSMZq4SyNoFGraCNuV5ZjbJHMvcYBLSV3rM\"},\n\n{\"private_key\":\"5JpX8v4y7HQ9EXLRGPXcPCVCqw5BLzP2drAbwJ94P3QXFxxwzkw\",\"public_key\":\"BTS8ftmc4mCUjnR43SPtQFg8xuJgUr82MKuBjvegrmdDasohZcpZw\",\"address\":\"BTSP1gitSEvGzCLCa9rsCCfQiRSzNQquDUxX\"},\n\n{\"private_key\":\"5HtEtfFYt1eGpE6uVWMyzMXzh8BBYfPyfH2A8Q8FQvXgdFXsc7N\",\"public_key\":\"BTS7hKorE5txmsT6qee9NNqcYqNvBU1Umxk1cV93Q1XPEbYCacpfM\",\"address\":\"BTSCSSgBtAUAGkhFbo6rbUMqtNTJteWaxHdG\"},\n\n{\"private_key\":\"5KNP4D9K3FL1gBtRtanhfgLZTpz1wcJVsLEQXonRMeAwzMDL2se\",\"public_key\":\"BTS51ABY2MWbn3W5NNW3JNJRDraEi4JbzEAmBa3jiTQJ7f99Z7xJ6\",\"address\":\"BTS21sMK9h93c1i29wLKi29xqKxqjvLSEarw\"}]\n\n> yfan\n\n{\"private_key\":\"5Kecd9SoyHEYbSrUnadGzSokptuTWNMKi4M4CgXh7dSNSzLkNLq\",\"public_key\":\"BTS7kD3ohag84b2EEWovg24oT5CrKBePYhchX5eVNduh3LsrZyUQW\",\"address\":\"BTSLbrRxMZvrVCE7UqdQVqawcLDwAT289pPp\"}\n\n\n\n# Build bitshares on MacOSX\n\nFollowing the tutorial on [Building on OS X](https://github.com/bitshares/bitshares-core/wiki/Building-on-OS-X)\n\n`git submodule update --init --recursive`\n\n# Build private Testnet\n\n**Ref**：\n\n1. [Private Testnet Set up](https://dev.bitshares.works/en/master/development/testnets/private_testnet.html#initial-compilation)\n2. [How to build your own bitshares testnet ](https://www.jianshu.com/p/0bd20134e9a2?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation)\n3. [BitShares 2.0 多节点私链部署](https://dpos.club/topics/118)\n\n在进行这部分内容的时候，不敢放手试的我做了很多无用功。总想玩出一点自己的花样，结果还是用了官方的`json`\n\ntutorial 2 中介绍了3个节点的testnet需要自己生成一定数量的密钥对(key pair) 于是我们就用到了下买呢command\n\n```\nprograms/genesis_util/get_dev_key BTS w1 w2 w3 admin\n// w1 w2 w3 分别代表3个节点\n// 但需要在每个节点上生成分别的\t`json` 文件 以对应w1 w2 w3的密钥对\n// json文件中规定了init acc需要有11个 \n// 创造自己的json时可以将init1-11都改作自己的w1 public key 以此类推\n// admin则可以去替代官方文件的nathan acc 成为核心资产的保管人\n```\n\n`genesis`文件中几个我认为需要强调的地方\n\n```json\n\"initial_balances\": [{\n      \"owner\": \"TSLbrRxMZvrVCE7UqdQVqawcLDwAT289pPp\", //这里填写yfan的addr\n      \"asset_symbol\": \"BTS\",\n      \"amount\": \"1000000000000000\"\n    }\n\"maintenance_interval\": 600, //原始文件中是86400，如果为了加快证人活跃程度可以改小\n\"extensions\": {\n        \"updatable_htlc_options\": {\n            \"max_timeout_secs\": 2592000,\n            \"max_preimage_size\": 1024000\n        }\n    }      \t\t\t\t\t//此部分在240行上下，声明是为了private testnet上htlc的部署\n```\n\n需要提出的是， json文件是不允许加任何形式comment的，Douglas老爷子的原意是防止有人用注释来规定解析指令（parsing directives）破坏了interoperability。所以上方那个反斜杠并不能一并被复制到原文件中。望周知。\n\n## Embed Genesis (optional）\n\n重新基于`genesis.json`进行rebuild\n\nstep：\n\n```shell\nmake clean\nfind . -name \"CMakeCache.txt\" | xargs rm -f\nfind . -name \"CMakeFiles\" | xargs rm -Rf\ncmake -DGRAPHENE_EGENESIS_JSON=\"$testnet/genesis/yfan_genesis.json\"\n```\n\n在上方这里可能会遇到报错，大概就是无法找到boost和openssl的root地址，所以我们需要再次在cmake的过程中声明\n\n```shell\ncmake -DGRAPHENE_EGENESIS_JSON=\"$testnet/genesis/yfan_genesis.json\"  -DBOOST_ROOT=/usr/local/opt/boost@1.60 -DOPENSSL_ROOT_DIR=/usr/local/opt/openssl/\n```\n\n> 命里无时莫强求… make中总是出错 还很难排查… cpp不是我的本命 这里就不继续下去了叭xx\n\n好的我又回来了！\n\n可能是之前在make clean的时候没有完全把之前遗留的文件删除彻底，又抑或者在用cmake之后无需进行二次make（不太说得通…\n\n 总之，孤注一掷的我把testnet整个文件夹拷贝出来并且删除了所有bitshares-BTS的文件之后重新git clone， make的进程就变的顺利了许多\n\n\n\n## 配置\n\n`./witness_node`启动将会在当前文件夹下建立一个data directory，并且在文件夹中生成相应的`config.ini`文件\n\n```bash\n./witness_node --data-dir data/my-blocktestnet --genesis-json genesis/yfan_genesis.json --seed-nodes \"[]\" --enable-stale-production\n```\n\n在这里会生成我们之前提到的Chain ID，节点的初始化已经完成。\n\n`enable-stale-production = true` 这里我们允许了witness_node生成旧的block/0 block 这一步可以在下方command里声明，因为我们一般不需要他，也可以在config.ini中提出。\n\n`--seed-nodes “[]”` 代表创建一个空节点种子列表，以免连接到default hardcoded（默认硬编码）种子。\n\n在生成的dir里找到config.ini文件 根据tutorial进行配置， 我们会将witness-id 进行多次声明，这授权witness_node去代表所列出的witness-id生成block，并指定签署这些block所需的私钥（privatekey）。通常情况下，每个见证人都在不同的节点上，但出于这个测试网的目的，我们将从所有见证人开始在单个节点上签署block。\n\n一个大佬的对config.ini的详细解释 [链接这里](https://www.jianshu.com/p/c47dba98480f)\n\n```shell\n# Endpoint for P2P node to listen on\n# p2p-endpoint 为当前节点对外广播的端口号 如果将这行注释的话 witness_node 将随机创建一个端口使用 这里我们将端口设置为对全网公开的8091\n#若用127.0.0.1:8091则代表只只允许本地访问\np2p-endpoint = 0.0.0.0:8091\n\n# P2P nodes to connect to on startup (may specify multiple times)\n# seed-node 代表着启动的时候连接的节点（若没有启动时希望连接节点，请不要将注释放开）\n# seed-node = \n\n# JSON array of P2P nodes to connect to on startup\n#启动后连接的节点数组，如果不希望连接任何节点，请按下面的方法进行；否则请按照注释方法进行\nseed-nodes = []\n# seed-nodes = [\"47.104.82.72:8092\"] \n\n# Pairs of [BLOCK_NUM,BLOCK_ID] that should be enforced as checkpoints.\n#这个命令对启动暂时是无用(用途为记录点，但具体细节还需要研究，暂时保持)\n# checkpoint = \n\n# Endpoint for websocket RPC to listen on\n# 这个命令很重要，最终由这个端口决定着区块链网页的等等客户端的连接 这里我们开放全网8090端口 客户端通过ws://服务器ip:8090 连接 非ssl\nrpc-endpoint = 0.0.0.0:8090\n\n# Endpoint for TLS websocket RPC to listen on\n# 这个跟上面一样区别是这个是采用ssl证书的\n# rpc-tls-endpoint = \n\n# The TLS certificate file for this server\n# ssl证书地址\n# server-pem = \n\n# Password for this certificate\n# ssl证书密码\n# server-pem-password = \n\n# File to read Genesis State from\n# 标志着见证节点从哪里获取创世文件 同命令行参数效果\n# genesis-json = \n\n# Block signing key to use for init witnesses,\noverrides genesis file\n# 可以重写创世文件中的见证人签名，具体用途暂时还没有尝试\n# dbg-init-key = \n\n# JSON file specifying API permissions\n# 允许客户端访问的api（一般是全部开放）\n# api-access = \n\n# Space-separated list of plugins to activate\n# 挂载的接口\n# plugins = \n\n# Enable block production, even if the chain is stale.\n# 这个比较重要，是否允许区块链节点产块，即使这个链被冻结（产生第1块或者长时间未使用），一般填true\nenable-stale-production = true\n\n# Percent of witnesses (0-99) that must be participating in order to produce blocks\n# 这个用途暂时未知\nrequired-participation = false\n\n# ID of witness controlled by this node (e.g. \"1.6.5\", quotes are required, may specify multiple times)\n# 当前节点控制的见证人id 格式 witness-id = \"1.6.5\" 可以添加多个\n# witness-id = \n\n# Tuple of [PublicKey, WIF private key] (may specify multiple times)\n# 对应区块签名的公私钥对\nprivate-key = [\"BTS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV\",\"5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3\"]\n\n# 下面的东西用途暂时不多所以先不继续介绍了\n# Tuple of [PublicKey, WIF private key] (may specify multiple times)\ndebug-private-key = [\"BTS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV\",\"5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3\"]\n\n# Account ID to track history for (may specify multiple times)\n# track-account = \n\n# Keep only those operations in memory that are related to account history tracking\npartial-operations = 1\n\n# Maximum number of operations per account will be kept in memory\nmax-ops-per-account = 1000\n\n# Elastic Search database node url\n# elasticsearch-node-url = \n\n# Number of bulk documents to index on replay(5000)\n# elasticsearch-bulk-replay = \n\n# Number of bulk documents to index on a syncronied chain(10)\n# elasticsearch-bulk-sync = \n\n# Log bulk events to database\n# elasticsearch-logs = \n\n# Use visitor to index additional data(slows down the replay)\n# elasticsearch-visitor = \n\n# Track market history by grouping orders into buckets of equal size measured in seconds specified as a JSON array of numbers\nbucket-size = [60,300,900,1800,3600,14400,86400]\n\n# How far back in time to track history for each bucket size, measured in the number of buckets (default: 1000)\nhistory-per-size = 1000\n\n# Will only store this amount of matched orders for each market in order history for querying, or those meet the other option, which has more data (default: 1000)\nmax-order-his-records-per-market = 1000\n\n# Will only store matched orders in last X seconds for each market in order history for querying, or those meet the other option, which has more data (default: 259200 (3 days))\nmax-order-his-seconds-per-market = 259200\n\n# RPC endpoint of a trusted validating node (required)\n# trusted-node = \n\n# Block number after which to do a snapshot\n# snapshot-at-block = \n\n# Block time (ISO format) after which to do a snapshot\n# snapshot-at-time = \n\n# Pathname of JSON file where to store the snapshot\n# snapshot-to = \n\n# declare an appender named \"stderr\" that writes messages to the console\n[log.console_appender.stderr]\nstream=std_error\n\n# declare an appender named \"p2p\" that writes messages to p2p.log\n[log.file_appender.p2p]\nfilename=logs/p2p/p2p.log\n# filename can be absolute or relative to this config file\n\n# route any messages logged to the default logger to the \"stderr\" logger we\n# declared above, if they are info level are higher\n[logger.default]\nlevel=info\nappenders=stderr\n\n# route messages sent to the \"p2p\" logger to the p2p appender declared above\n[logger.p2p]\nlevel=info\nappenders=p2p\n```\n\n# 终于要启动测试网啦！\n\n```shell\n./witness_node --data-dir data/my-blocktestnet --enable-stale-production --seed-nodes \"[]\"\n```\n\n通过p2p网络连接到现有witness-node或从现有数据目录获取区块链状态blockchain state from an existing data directory的后续运行不需要具有--enable-stale-production标志。\n\nFor testing purposes, the `--dbg-init-key` option will allow you to quickly create a new chain against any genesis file, by replacing the witnesses’ block production keys. 通过替换witnesses’block的密钥 （未举例 稍难理解\n\nEach wallet is specifically associated with a single chain每个钱包只与单独的一条chain相关联, specified by its chain ID. This is to protect the user from (e.g., unintentionally) using a testnet wallet on the real chain.（为了防止主网误用）\n\n# Chain ID的作用\n\n> Chain ID is cc546c96f8d3676f0b0f34fac209f5f48032d094d65eca7bbfebd62c6e6342e2\n>\n> Chain ID 2 is 4018d7844c78f6a6c41c6a552b898022310fc5dec06da467ee7905a8dad512c8\n\nChain ID(old) : e10e9742420a7a52d4ce6a7c70867a953316b19de2d861a10bc21efcc095e5ed\n\nchain ID new : 8e0c5b1e2e37487ce5b5d40b5acc57d8387992ef2ea82562701871319674dc52\n\nChain ID是genesis状态的哈希值，所有交易签名仅对单个的Chain ID 有效（valid）因此编辑genesis.json文件将影响到 与所有存在的链的同步sync with all existing chains \n\n> 除非其中某个链的genesis file与你的相同\n\n如果需要build 多个node以防其中一个break down，我们需要将node-2和node-3也设置成witness节点。\n\n这里就需要之前记录的chain ID\n\n```shell\n./cli_wallet --wallet-file=genesis/yfan_genesis.json --chain-id 8e0c5b1e2e37487ce5b5d40b5acc57d8387992ef2ea82562701871319674dc52 --server-rpc-endpoint=ws://【任意一个节点的ip或域名】:11011\n```\n\n> 但是怎么说呢，我在初始阶段还没打算建多个节点 所以这里的节点ip我不是很清楚\n\n\n\n# 创建Cli-wallet\n\n下一步则是需要建立一个新的wallet来连接你private testnet上的的witness-node，需要声明chainID以及server地址\n\n在测试网启动时运行下面的command\n\n```sh\n./cli_wallet --wallet-file \n\t\t\t\t\t\t//钱包的配置文件目录,这里有个坑，如果不知道具体文件时不需要声明，容易出错\n\t\t\t\t\t\tfile/wallet_yfan.json\n            --chain-id //连接的区块链ID\n           8e0c5b1e2e37487ce5b5d40b5acc57d8387992ef2ea82562701871319674dc52\n           --server-rpc-endpoint //连接见证人节点的websocket rpc地址\n           ws://127.0.0.1:8090 \n           -u //用户名'' -p //密码 ''\n```\n\n`./cli_wallet --wallet-file file/wallet_yfan.json --chain-id 8e0c5b1e2e37487ce5b5d40b5acc57d8387992ef2ea82562701871319674dc52 --server-rpc-endpoint ws://127.0.0.1:8090 -u \" -p \" `\n\n这里遇到了报错，error message如下：\n\n```\nStarting a new wallet with chain ID cc546c96f8d3676f0b0f34fac209f5f48032d094d65eca7bbfebd62c6e6342e2 (from CLI)\n\n2257504ms th_a       main.cpp:194                  main                 ] wdata.ws_server: ws://127.0.0.1:8090 //首先这里我就不太懂为什么server会监听8090端口 而不是我规定的11011，这两个是不同的东西吗\n\n0 exception: unspecified\n\nUnderlying Transport Error\n\n    {\"message\":\"Underlying Transport Error\"}\n\n    fc::asio worker #1  websocket.cpp:465 operator()\n\n\n\n    {\"uri\":\"ws://127.0.0.1:8090\"}\n\n    th_a  websocket.cpp:694 connect\n\n```\n\n> Google 一搜发现了很多类似的报错疑问，调试如下，在运行testnet的时候加入 `--rpc-endpoint=127.0.0.1:8090` 很明显，这个和我们之前在config.ini中声明的不是一个，但是这种local的testnet好像统一连接到8090这个端口，那么尽管我在生成wallet的时候写了11011，程序中也是回到8090上监听。\n\nConfused...github上的issue中有人解答了\n\n> there is a bug with boost 1.60, need to remove the white space after `-s` (and any other options) to let the program recognize the parameter specified\n\n但是很明显情况不同，[接着我发现了另一个](https://bitsharestalk.org/index.php?topic=25504.0)，so far无人解答。\n\n那既然这样 下面的测试我就在运行node的时候加入--rpc-endpoint规定端口8090的指令，然后开始cli_wallet部分的排雷。\n\n（这部分的东西还是存疑\n\n## 一些Command的解释\n\n**Ref:**[bitshares研究系列【初识cli_wallet】](https://busy.org/@chaimyu/bitshares-cliwallet)\n\n进入钱包后的第一个步骤是设置密码：\n\n```shell\n3058094ms th_a  main.cpp:199  main     ] wdata.ws_user:  wdata.ws_password:  \nPlease use the set_password method to initialize a new wallet before continuing\nnew >>> set_password secret\nnull\nlocked >>>\n```\n\n根据官方的建议 这里的cli-wallet的密码为supersecret，接着我们就可以用这个密码来解锁并且导入nathan这个账户，余额信息都在保存在账户里，导入的时候需要知道**name**和**private key**\n\n```sh\nlocked >>> unlock secret\nunlocked >>> import_key yfan\n\"5Kecd9SoyHEYbSrUnadGzSokptuTWNMKi4M4CgXh7dSNSzLkNLq\"\nunlocked >>> import_balance yfan [\"5Kecd9SoyHEYbSrUnadGzSokptuTWNMKi4M4CgXh7dSNSzLkNLq\"] true\nunlocked >>> list_account_balances yfan\n```\n\n在导入nathan账户的余额后，我们可以通过上面的指令来查询 结果如下\n\n`10000000000 BTS`\n\n这时候genesis文件中的账户已经被我们导入，但我们仍需要新建一个账户来实现转账功能，这时我们首先需要*注册商账户*用来提供资金，并且是LTM（终身会员）\n\n```shell\nunlocked >>> upgrade_account yfan true\nunlocked >>> get_account yfan\n```\n\n这个时候返回的信息中比较重要的改动就是`membership_expiration_date`从之前的1970-01-01改动到了1969-12-31，表示成功升级。\n\n\n\n接下来就是用**yfan**这个注册商来注册用户test1，在此之前，我们需要key pair\n\n```shell\nunlocked >>> suggest_brain_key\n{\n  \"brain_priv_key\": \"TUCUMAN TITTY WASHPOT WHID AQUABIB CHLAMYD STENION UPSCREW CONTEXT AUDIT TAPLET PERITE PENNET LEKHA CUTOFF SNED\",\n  \"wif_priv_key\": \"5Hwv9FXXrMd4o3FaHFJRLwuMmsihLz29bAGQYon4arK6ZzXCQhB\",//账户的private key\n  \"pub_key\": \"BTS7UmYZJAcZ8wEFEXTDHkLtaW269iAA42qQWxu9gyBJ5het17pco\"// 账户的public key\n}\nunlocked >>> register_account john BTS7UmYZJAcZ8wEFEXTDHkLtaW269iAA42qQWxu9gyBJ5het17pco\nBTS7UmYZJAcZ8wEFEXTDHkLtaW269iAA42qQWxu9gyBJ5het17pco yfan yfan 0 true\n```\n\n通过help()指令我们可以看到转账的时候指令格式如下：\n\n`transfer(string from, string to, string amount, string asset_symbol, string memo, bool broadcast)`\n\n分别需要付款方，收款方，数量，资产符号（在bitshares下为BTS），附言，广播（布朗值）按照规定\n\n```shell\nunlocked >>> transfer yfan john 100000 BTS \"Transfer Test1\" true\nunlocked >>> list_account_balances john\nunlocked >>> list_my_accounts //这时只有yfan一个用户在list里\n```\n\n转账成功，可以查询到john的账户里有了基本的100000 BTS的资金余额，相似的，我们可以在这个时候为john也开一个钱包。如果你没有记下来之前`suggest_brain_key`中提供的“wif_priv_key”，也可以用`get_private_key + account pub_key`来获得。\n\n\n\n### 成为witness\n\n```bash\nunlock >>> import_key john 5Hwv9FXXrMd4o3FaHFJRLwuMmsihLz29bAGQYon4arK6ZzXCQhB\nunlock >>> list_my_accounts //在导入john的私钥之后，这里就能查看两个账户信息\nunlock >>> create_witness john \"http://www.john\" true\nunlock >>> get_witness test1\n{\n  \"id\": \"1.6.12\",\n  \"witness_account\": \"1.2.18\",\n  \"last_aslot\": 0,\n  \"signing_key\": \"BTS8feyvbFfVHcMPncoxXbLUPW72yTQL219y8x19y5sukYAMAH4TM\",\n  \"vote_id\": \"1:22\",\n  \"total_votes\": 0,\n  \"url\": \"http://www.test1\",\n  \"total_missed\": 0,\n  \"last_confirmed_block_num\": 0\n}\n```\n\n`witness_node`需要`signing_key`和对应的私钥，并联合id才能生成区块。通过`get_private_key`获取该签名密钥的私钥\n\n```bash\nunlocked >>> get_private_key BTS7UmYZJAcZ8wEFEXTDHkLtaW269iAA42qQWxu9gyBJ5het17pco\n\"5Hwv9FXXrMd4o3FaHFJRLwuMmsihLz29bAGQYon4arK6ZzXCQhB\"\n\n```\n\n要想让证人生产区块就必须给新建的证人对象投票让其成为活跃证人：\n\n```bash\nvote_for_witness john john true true\n\n```\n\n在一段维护时间后可以使用命令`get_dynamic_global_properties`查看`next_maintenance_time`字段的值。只有等到下一个维护间隔后，投票才会统计，证人 才有可能成为新的活跃证人，这个maintain时间可以由之前的genesis文件中更改。\n\n一旦下一次维护时间间隔过去后，可以使用`get_global_properties`命令来查看到当前的活动证人列表，根据证人`id`查看新证人已被投票成为活跃证人。一旦成为活跃证人后， 就可以让新证人节点生产区块。\n\n将证人id`witness-id=“1.6.12”`以及test1的密钥对添加到privatekey中，并且再次运行`./witness_node --data-dir data/my-blocktestnet --enable-stale-production` 去查看是否有用witness成功出块 `witness.cpp:181               block_production_loo `\n\n# committee members（optional？\n\n```shell\nCreate⬇️:\ncreate_account_with_brain_key com0 com0 nathan nathan true\ncreate_account_with_brain_key com1 com1 nathan nathan true\ncreate_account_with_brain_key com2 com2 nathan nathan true\ncreate_account_with_brain_key com3 com3 nathan nathan true\ncreate_account_with_brain_key com4 com4 nathan nathan true\ncreate_account_with_brain_key com5 com5 nathan nathan true\ncreate_account_with_brain_key com6 com6 nathan nathan true\n\ncreate_account_with_brain_key [your_brain_key] \"name\" \"nathan\" \"nathan\" true\n\n\n\nUpgrade⬇️:\ntransfer nathan com0 100000 BTS \"some cash\" true\ntransfer nathan com1 100000 BTS \"some cash\" true\ntransfer nathan com2 100000 BTS \"some cash\" true\ntransfer nathan com3 100000 BTS \"some cash\" true\ntransfer nathan com4 100000 BTS \"some cash\" true\ntransfer nathan com5 100000 BTS \"some cash\" true\ntransfer nathan com6 100000 BTS \"some cash\" true\n\nupgrade_account com0 true\nupgrade_account com1 true\nupgrade_account com2 true\nupgrade_account com3 true\nupgrade_account com4 true\nupgrade_account com5 true\nupgrade_account com6 true\n\nRegister⬇️:\ncreate_committee_member com0 \"http://www.com0\" true\ncreate_committee_member com1 \"http://www.com1\" true\ncreate_committee_member com2 \"http://www.com2\" true\ncreate_committee_member com3 \"http://www.com3\" true\ncreate_committee_member com4 \"http://www.com4\" true\ncreate_committee_member com5 \"http://www.com5\" true\ncreate_committee_member com6 \"http://www.com6\" true\n\nVote⬇️:\nvote_for_committee_member nathan com0 true true\nvote_for_committee_member nathan com1 true true\nvote_for_committee_member nathan com2 true true\nvote_for_committee_member nathan com3 true true\nvote_for_committee_member nathan com4 true true\nvote_for_committee_member nathan com5 true true\nvote_for_committee_member nathan com6 true true\n\npropose_parameter_change com0 {\"block_interval\" : 6} true\n\n```\n\n# second node\n\n这一部分的内容很好理解，如果想要建立一个新的节点（基于同一个genesis文件）并且将它和之前的节点连接起来，那么就得获取之前节点的`p2p-endpoint`的地址作为新node的`seed-node`，举🌰：\n\nNode1 config.ini\n\n```ini\np2p-endpoint = 127.0.0.1:11010\n# seed-node =                // add a seed node of your own\n\nrpc-endpoint = 127.0.0.1:11011\n\n```\n\nNode2 config.ini\n\n```ini\np2p-endpoint = 127.0.0.1:11015\nseed-node = 127.0.0.1:11010 \n#这里用第一个节点的p2p地址来作为seed-node\n\nrpc-endpoint = 127.0.0.1:11020\n\n```\n\n在另一个节点上运行\n\n`./witness_node --data-dir data/my-blocktestnet2 --genesis-json genesis/yfan_genesis.json -s 127.0.0.1:8091` \n\n按道理...结果收到Got block则为成功，但我之前误打误撞成功收到了block，之后就再也没有过了（也不知道哪个才是错的\n\n**失败（下次再战**\n\n\n\n# HTLC Deploy\n\n首先，为了测试的效果，需要有两个cli-wallet的 test_accounts, 这两个账户可以同时存在于一个wallet文件中。 如上，我们可以使用`yfan`和`test1`。转账方：yfan必须有一定的balances，test1可以没有余额。  \n\n##### Step 1\n\n[通过网站生成](https://passwordsgenerator.net/sha256-hash-generator/) preimage（原像）的SHA-256哈希值，keep track几个重要的内容：\n\n1. **preimage_text**：yfan_Test_CrosscHain_14yhl9T\n2. **preimage_hash**：47C28C2C6728B718D38021D5C624F106DA8A3B3C14351DCE3BC7012427779A9B\n3. **preimage_length**（包括空格的character数量）单位为字节byte ：28\n\n##### Step 2\n\n生成HTLC：\n\n```cli\nhtlc_create <from> <to> <amount> <symbol> <hash_algo> <preimage_hash> <preimage_length> <expiration> <broadcast>\ne.g.\nhtlc_create yfan john 100 BTS SHA256 47C28C2C6728B718D38021D5C624F106DA8A3B3C14351DCE3BC7012427779A9B 28 1000 true\n\n```\n\n在这个地方我持续碰到了assert exception\n\n> {\"error\":\"Assert Exception: htlc_options: HTLC Committee options are not set.”…\n\n在多次查询无果后，我打开了bitshares的issue版面搜到了一个回答 [ref](https://github.com/bitshares/bitshares-core/pull/1833)，目前master上的genesis-dev.json文件中并没有申明htlc组件，在private testnet上就会出现htlc command报错，due to the related missing committee member parameters. The easier to do is to add them to the genesis file. This pull add the needed ones to developer genesis version. `htlc_create` just works with this addition and a new private testnet using this genesis.\n\n但是在这里我就发挥了自己始终适用笨办法的耗时费力技能….sad face\n\n我首先看着文件去找了本地的那个准备直接在上面改动，但改动完后却又担心有其他相对应的文件在make的过程中会不同，想着把develop branch上的文件pull下来，不会指令不敢瞎操作。\n\n最后我还是删了之前的文件夹下载了-b develop的版本，看了一下develop的 readme，为了cmake和make来编译和安装这个环境不出问题，我又checkout master回到了master分支…（make的耗时极长\n\n总之我打算在创建private testnet的时候远程拉取develop branch上的libraries/egenesis/genesis-dev.json文件到本地使用...\n\n### 蠢哭了\n\n原来只需要在自己的创世文件中添加`extensions`声明就可以重新新建一个private testnet，相应的，我更新了之前的账户信息。目前htlc就可以被激活了，返回的json响应如下：\n\n```json\n{\n  \"ref_block_num\": 310,\n  \"ref_block_prefix\": 3835468172,\n  \"expiration\": \"2019-07-15T13:47:45\",\n  \"operations\": [[\n      49,{\n        \"fee\": {\n          \"amount\": 200000,\n          \"asset_id\": \"1.3.0\"\n        },\n        \"from\": \"1.2.17\",\n        \"to\": \"1.2.18\",\n        \"amount\": {\n          \"amount\": 10000000,\n          \"asset_id\": \"1.3.0\"\n        },\n        \"preimage_hash\": [\n          2,\n          \"47c28c2c6728b718d38021d5c624f106da8a3b3c14351dce3bc7012427779a9b\"\n        ],\n        \"preimage_size\": 28,\n        \"claim_period_seconds\": 1000,\n        \"extensions\": []\n      }\n    ]\n  ],\n  \"extensions\": [],\n  \"signatures\": [\n    \"202dbfab91faba45ee081d61c67890764aa90a95961f9d5680249bbc93ba423e404df9fe8636a86889db98cd6d03bdc3cf4b10332d84dee2d97218d12d2d16d1fe\"\n  ]\n}\n```\n\n锁定前余额：9999887978.96193 BTS\n\n锁定后余额：9999887876.96193 BTS\n\n##### step 3\n\njohn Before amount:85077.94336 BTS\n\n从这一步开始就是收款方的操作了，首先查看账户最近历史操作信息，可以发现转账发起方生成的htlc内容包含：\n\n1. htlc_database id\n2. 哈希算法\n3. 哈希值\n4. 转账费用\n\n接下来通过get_htlc+ database id来获取具体contract里的内容包括他将要过期的时间，兑换这个token则需要使用htlc_redeem+database id+account+破译出的preimage+最后broadcast为true，再次查看余额就会发现转账成功\n\n```json\nunlocked >>> get_account_history john 1\n2019-07-15T13:47:20 Create HTLC to john with id 1.16.0 preimage hash: [SHA256 47c28c2c6728b718d38021d5c624f106da8a3b3c14351dce3bc7012427779a9b] (Fee: 2 BTS) \nunlocked >>> get_htlc 1.16.0\n{\n  \"transfer\": {\n    \"from\": \"yfan\",\n    \"to\": \"john\",\n    \"asset\": \"BTS\",\n    \"amount\": \"100\"\n  },\n  \"conditions\": {\n    \"htlc_lock\": {\n      \"hash_algo\": \"SHA256\",\n      \"preimage_hash\": \"47c28c2c6728b718d38021d5c624f106da8a3b3c14351dce3bc7012427779a9b\",\n      \"preimage_size\": 28\n    },\n    \"time_lock\": {\n      \"expiration\": \"2019-07-15T14:03:55\",\n      \"time_left\": \"5 minutes in the future\"\n    }\n  }\n}\nunlocked >>> htlc_redeem 1.16.0 john \"yfan_Test_CrosscHain_14yhl9T\" true\n{\n  \"ref_block_num\": 468,\n  \"ref_block_prefix\": 3932948519,\n  \"expiration\": \"2019-07-15T14:00:55\",\n  \"operations\": [[\n      50,{\n        \"fee\": {\n          \"amount\": 200000,\n          \"asset_id\": \"1.3.0\"\n        },\n        \"htlc_id\": \"1.16.0\",\n        \"redeemer\": \"1.2.18\",\n        \"preimage\": \"7966616e5f546573745f43726f7373634861696e5f313479686c3954\",\n        \"extensions\": []\n      }\n    ]\n  ],\n  \"extensions\": [],\n  \"signatures\": [\n    \"20273c975297e19ceeed0b28e8a3b3c0b457e88d67005f4f9bd3758bcee331bcfb51cec758b01d14d18d5378828c805eff3c272d35e7ce1913a5c77a478468fe66\"\n  ]\n}\nunlocked >>> list_account_balances john                 \n86075.94336 BTS  \n\nunlocked >>> list_account_balances yfan\n9999886874.96193 BTS\n\n```\n\n其他的函数功能测试response：\n\n```json\nunlocked >>> htlc_create yfan john 10000 BTS SHA256 47C28C2C6728B718D38021D5C624F106DA8A3B3C14351DCE3BC7012427779A9B 28 1000 true\n{\n  \"ref_block_num\": 650,\n  \"ref_block_prefix\": 2028552969,\n  \"expiration\": \"2019-07-17T10:05:10\",\n  \"operations\": [[\n      49,{\n        \"fee\": {\n          \"amount\": 200000,\n          \"asset_id\": \"1.3.0\"\n        },\n        \"from\": \"1.2.17\",\n        \"to\": \"1.2.18\",\n        \"amount\": {\n          \"amount\": 1000000000,\n          \"asset_id\": \"1.3.0\"\n        },\n        \"preimage_hash\": [\n          2,\n          \"47c28c2c6728b718d38021d5c624f106da8a3b3c14351dce3bc7012427779a9b\"\n        ],\n        \"preimage_size\": 28,\n        \"claim_period_seconds\": 1000,\n        \"extensions\": []\n      }\n    ]\n  ],\n  \"extensions\": [],\n  \"signatures\": [\n    \"1f5ee3272734880cba14486497c16fd84212f51efb62ed51f745699cca02be09f121d9f8c2ab8de4e08b5d0521e39e8ec332dbf75b3c1a820fc266c761e3aa7f44\"\n  ]\n}\nunlocked >>> get_account_history yfan\n10 assert_exception: Assert Exception\na0 != e: too few arguments passed to method\n    {}\n    th_a  api_connection.hpp:169 call_generic\nunlocked >>> get_account_history yfan 1\n2019-07-17T10:04:45 Create HTLC to john with id 1.16.2 preimage hash: [SHA256 47c28c2c6728b718d38021d5c624f106da8a3b3c14351dce3bc7012427779a9b] (Fee: 2 BTS) \n\nunlocked >>> htlc_extend 1.16.2 yfan 200 true\n{\n  \"ref_block_num\": 672,\n  \"ref_block_prefix\": 3596273135,\n  \"expiration\": \"2019-07-17T10:07:10\",\n  \"operations\": [[\n      52,{\n        \"fee\": {\n          \"amount\": 200000,\n          \"asset_id\": \"1.3.0\"\n        },\n        \"htlc_id\": \"1.16.2\",\n        \"update_issuer\": \"1.2.17\",\n        \"seconds_to_add\": 200,\n        \"extensions\": []\n      }\n    ]\n  ],\n  \"extensions\": [],\n  \"signatures\": [\n    \"200ec6e4f3104e773a7b185ae04ef5953fbda7929ac2c3168daab0abb3ccb1238b1145ad19d10e1c010a6f9c00b9ea2ff2919502884cc8bce87e2bcce6afd41895\"\n  ]\n}\nunlocked >>> \n\n```\n\n\n\n##### prepare\n\n```cpp\ntransaction_obj htlc_prepare(depositor, quantity, symbol, recipient, hash_algorithm, preimage_hash, preimage_length, timeout_threshold, htlc_preparation_fee)\n  \n  \n  Validate: HTLC signed by requisite `authority` for `depositor` account \n  Validate: `depositor` account has requisite `quantity` of `symbol` asset for the `guarantee`\n  Validate: `timeout_threshold` < now() + GRAPHENE_HTLC_MAXIMUM_DURRATION\n  Calculate: `required_fee` = GRAPHENE_HTLC_OPERATION_FEE + GRAPHENE_HTLC_DAILY_FEE * count((`timeout_threshold` - now()), days)\n  Validate: `depositor` account has requisite `quantity` of BTS for `required_fee`\n  Validate: `recipient` account exists\n  Validate: `preimage_length` does not exceed GRAPHENE_HTLC_MAXIMUM_PREIMAGE_LENGTH\n  Validate: `preimage_hash` well formed\n  Update: BTS balance of `depositor` based on `required_fee`)\n  contract = new htlc_obj\n  Set: `contract.depositor` = `depositor`\n  Set: `contract.recipient` = `recipient`\n  Set: `contract.hash_algorithm` = `hash_algorithm`\n  Set: `contract.preimage_hash` = `preimage_hash`\n  Set: `contract.preimage_length` = `preimage_length`\n  Set: `contract.timeout_treshold` = `timeout_threshold`\n  Transfer: from `depositor` account to `contract.quantity` of `contract.symbol`\n  \n  \n  return results\n```\n\n##### redeem\n\n```cpp\ntransaction_obj htlc_redeem(fee_paying_account, id, preimage, htlc_redemption_fee)\n  Validate: transaction signed by requisite `authority` for `fee_paying_account` // any account may attempt to redeem\n  Get: get_htlc(id)\n  Validate: `fee_paying_account` account has requisite `quantity` of BTS for `htlc_redeem_fee` and `htlc_kb_fee`\n  Update: balance of `fee_paying_account` based on total fees\n  // Evaluate: timelock\n     if now() < `timeout_threshold` then return error // \"timeout exceeded\"\n  // Evaluate: hashlock\n     if length(preimage) != `id.preimage_length` then return error // \"preimage length mismatch\"\n     Calculate: `preimage_hash` = hash(preimage)\n     if `preimage_hash` != `id.preimage_hash` then return error // \"invalid preimage submitted\"\n     Update: balance of `id.recipient` add asset `id.symbol` of quantity `id.quantity`\n     Add: transaction to mempool \n     Set: `id.preimage_tx_id` = `transaction_id` \n     Cleanup: memory allocated to this htlc\n     Virtual Operation: Update account history for `depositor` to reflect redemption as by default the above operation will only appear for `redeemer`\n\n     return: results\n```\n\n##### extend expiry\n\n```cpp\ntransaction_obj htlc_extend_expiry(depositor, id, timeout_threshold, htlc_extention_fee)\n  Validate: 'depositor' = get_htlc(id).depositor \n  Validate: `timeout_threshold` < now() + GRAPHENE_HTLC_MAXIMUM_DURRATION\n  Calculate: `required_fee` = GRAPHENE_HTLC_DAILY_FEE * count((`timeout_threshold` - now()), days)\n  Validate: `depositor` account has requisite `quantity` of BTS for `required_fee`\n  Update: BTS balance of `depositor` based on `required_fee`)\n  Set: `contract.timeout_treshold` = `timeout_threshold`\n  return results\n```\n\n该怎么实现与外部blockchain的转账呢...\n\n------\n\nTo be continued\n\n<center> -学术7-y.","tags":["Project"],"categories":["KTH"]},{"title":"一个预告和近况","url":"/2019/06/19/2019-6-19/","content":"\n# 我回归了\n> 信誓旦旦不能抛弃这个小站子的我，却也有半年没有更新任何东西\n> \n> 甚至我这半年来都没有可以拿出手的学习进程\n> \n> 说起来 人生又丧气了许多 TT\n> \n> 当然，我爸的诗也没有可以拿的出手了的kkk（误 \n> 其实是俺爸managed working on手机微信公众号平台了 恭喜找到东西做的他攻克中年危机成功！\n\n# 区块链踏水\n为什么要称之为踏水而不是试水呢，是因为我在区块链的海洋里真的只接触了冰山一角，还弄的一团糟（扶额...\n\n起因是自己找了个区块链技术方向的毕业设计，哇说出去给谁听都不明觉厉啊。我当时一个区块链世界的小懵懂可是以为自己会通过毕设变得好棒棒呢。 可是谁曾想我的题目要求只是~~简简单单的~~对于跨链技术的研究及分类比较，最重要的deliverable可能是提出一个目前相对通用的跨链技术需求, 嗯 还是提出需求。\n\n得，想找个技术类的来提升、挑战再不济锻炼一下自己的梦算是破裂了，我这项目就一个大字：**RESEARCH!**\n\n##### *很快我就消极怠工了....*\n\n该干的活还得干，几次与老板的沟通下来，我逐渐感知了整个项目存在的意义（并不，在我前前后后看了20多个不同跨链项目的whitepaper和网上千篇一律的review后，我彻底 down了。虽说跨链也就这两年的事情，研究起来颇具困难，但按理说怎么样的一块儿硬骨头也有的啃呀！打开texpad看了看我的内容，我深感答辩的艰难，没有统一的实现方式，一个个白皮书很容易看了就忘。从官方介绍，技术实现，跨链方式，共识机制，想总结，想对比，总也找不到合适的方式。每一个项目的深入研究是不可能了，但是因为内容一点点的增多，写论文还是有的写的。 不知不觉已经码了60多页...\n\n但作为工科生，硕士毕业设计怎么也不能靠全部的理论和官方文件rephrase来支撑吧。报告里的文字码的越多，我越害怕后面的分析结论两章无从下手，以至于没有内容可写。\n\n得测试呀！从BTC-relay, Interledger, Cosmos到wanchain, PalletOne,没有一个的介绍不是把自己夸的天花乱坠的。不能理解也不是很关心的我的老板在分析这方面居然给我提了让我去google \"Project name+ issue\" 寻找内容的建议。 我满脸问号的同时一口老血 完蛋了 毕不了业了 TAT\n\n\n\n> 最终还是选择了用简单程序进行测试\n> 于是有了我真正意义上尝试的一次区块链经历...\n> 写个repo记录一下\n> 这次耗时耗力的东西最后我用不上也说不定...\n\nTo be continued\n\n<center> -学术7-y.","tags":["Project"],"categories":["KTH"]},{"title":"家父酌诗2018/10/7","url":"/2018/11/19/10-7/","content":"\n> 整理第三篇  \n> 胡杨从一早就是我父亲的象征与图腾  \n> 这种精神在他身上愈久弥新  \n> 非常自豪(´◉౪◉｀)\n\n\n# 2018.10.07\n十一长假，印象最深的还是\n\n## <center>  胡杨\n\n> **戈壁胡杨耀夕阳，满目金黄闪秋光。**  \n> **千年沧桑展铮骨，寒暑轮换守边疆。**   \n> **笑对寂廖望岁月，淡看凄凉度寒霜。**  \n> **多少人去未曾记，万古英名天地荒。**\n\n![1w](/1w.JPG)\n\n<center> -凡员外","tags":["Poems"],"categories":["俺爸xx"]},{"title":"实现小站的国内访问(。≖ิ‿≖ิ)","url":"/2018/11/17/实现小站的国内访问/","content":"\n# - 之前的抱怨还不是因为自己懒 -\n\nemmm 想来技术白痴的日常可能就和我差不多了吧。（不我觉得我不傻 还是因为懒）\n\n## 部署平台\n\n身在国外，访问github的速度肯定是足够的，这个网站存活的前两周，域名解析里只加了github page的CNAME和欧洲地区的IP地址。 在我还沾沾自喜的时候，国内的朋友告诉我 “别乐了，我们看不到”\n\n> 好的吧...  \n\n在我寻思是不是该远程指导他们翻墙的时候,谷歌给我介绍了一个国内的开源代码托管平台——[Coding.net](https://coding.net/) 不得不说，在北欧去访问这个网站速度的确十分的堪忧。 总之注册并进了网站之后，整体给我的感觉就是汉化了的github，基本操作也相似，于是我算是知道很多我只会用英语来说的名词究竟该怎么翻译了xxx..\n\n部署基本流程和github page是一毛一样的，甚至在他是全中文（并且我也熟了）的情况下，基本上几分钟就搞好了自己的个人博客，这时候在原hexo的配置文件下找到`deploy`标签下的 git，添加上coding的link和相应branch，咻！\n\n可以登陆*username*.coding.me去洋洋得意两分钟了！\n\n### 双线解析撞车\n\n问题出在了关联自定义域名的时候... 在我ping这个网址的时候发现，他的ip是动态的，所以我们在添加解析记录时就不合适使用A类型啦。这里我添加了两条记录都是CNAME指向我的部署地址。\n\n因为是双线解析，绑定域名时总是报`域名未连通`的问题。 查询了官方FAQ的解决方案就是\n\n 1. Coding绑定域名需要将解析中CNAME除了指向`coding.me`的都删除\n 2. 等待github的解析TTL时间过去，再进行绑定，成功！\n 3. 这个时候我的解析线路默认都是去了Coding这个平台。\n 4. 接下来为了我在国外的访问速度，添加回了之前被删除的两条记录，设置线路为境外。\n\n\n也是一番不小的折腾啦哈哈，网站彻底搭建成功，国内ip地址是动态的，ping域名时因为自己在国外，所以显示的是github page所分配的ip。\n\n> 我不是那种写教程的人，只会把自己的排雷过程记录一下  \n> 所以有啥疑问还烦请大家移步google，相信我，大神数不过来～\n\n\n<center> -折腾的7-y.","tags":["折腾日记"],"categories":["Self"]},{"title":"家父酌诗2018/10/30","url":"/2018/11/14/fyxautumn/","content":"\n> 作为女儿，其实建这个category的最大心愿是给家人看看的  \n> （虽然现在还没能实现国内阅读...  \n> 这里俺爸的诗每一则都是我精挑细选的LOL\n\n\n# 2018.10.30\n\n一场风后，天更冷了。层林尽染的晚秋也要走了。\n\n\n## <center>  鹧鸪天• 晚秋\n\n> <center>  **惘顾流年愁上头，**  \n> **枝枯叶落意难留。**   \n> **韶光己逝雄心远，**  \n> **岁月蹉跎壮志休。**  \n\n \n> <center>  **书半卷，茶一盅，**\n> <center>  **唯学茗香雅韵留。**\n>  <center> **偷闲且看风飘叶，**\n> <center>  **留得从容赏晚秋。**\n\n\n![autumn](fyxautumn/1.jpg) \n\n\n<center> -凡员外","tags":["Poems"],"categories":["俺爸xx"]},{"title":"家父酌诗2018/11/04","url":"/2018/11/11/fyx/","content":"\n> 父亲有一天很严肃的说要向我请教点东西  \n> 我一个激灵饶有兴趣的听他后面的话    \n> 原来他发在朋友圈里的小诗已经越攒越多了，想开个微信公众号整理一下并且记录一点技术上的东西  \n> 海外指导着玩这些还真的不容易呢 总算开起来了却从没见他发帖  \n> 问了半天才知道他嫌弃人家不能手机操作눈_눈 \n\n> 总之我这里给他备个份吧 万一哪天想看呢哈哈哈\n\n# 2018.11.04\n\n前日，有同学自远方来，不想却是一场同年同月同日的生日聚会。\n\n## <center>  同学缘聚 \n\n> <center>  **东兔西乌又逢秋， 韶华不为青春留，**  \n> **昔日同窗情缘厚， 万里边城来聚首。**   \n> **怎寻少年多壮志， 黯然华发忆风流，**  \n> **今夕共饮祝寿酒， 知命天年无烦忧。**\n\n\n\n\n![leaf](fyx/IMG_5315.jpg)  \n\n\n<center> -凡员外","tags":["Poems"],"categories":["俺爸xx"]},{"title":"试图往主站添加音乐Try 1","url":"/2018/11/10/试图往主站添加音乐Try-1/","content":"# - 都怪主页太干净啦(｡•ˇ‸ˇ•｡) -\n\n> 初心是想添加一个背景音乐  \n> 一个一进到网站就默默自己播放的那种乖巧的背景音乐  \n> Like the old times when we wrote blogs held by *Sina*  LOL🤣\n\n花了大概有俩小时没干正事去倒腾这个，期间又是搜plugins，又是尝试添加`frame`标签 `embed`标签 `audio`标签种种. 网上好理解的例子都是国内大大们写的，自然音乐平台用的网易云。 \n\n我这种嫌弃网易云（误）且在海外的技术孤儿，看了看平常自己听音乐用的Spotify，深感将是一场恶战...\n\n## Plugins\n\n到底是基于hexo，查了几个教程都是劝不要这么加音乐（因为会降低hexo本身的loading速度）我还是不死心的去查了plugins。\n\n相较于知乎上的那个回答，2018的hexo已经有不少大牛写了music标签的插件供我们这些折腾王去玩玩，理所当然地看到了[hexo-tag-spotify](https://github.com/ivanovyordan/hexo-tag-spotify)\n\n 这个插件的README写的还算中肯，小白痴如我安装好之后首先在config里跳了一个大坑，看了有个中文的教程我就傻瓜式的照搬了人家的配置，当时还觉得哇这个配置的comment写的可真详细，以后不用怕啦肯定看的懂啦！结果就在deploy的时候找不到git了，百思不得其解的我把报错信息谷歌了五六页，无非是让我重新安装hexo-deployer-git，在不断撞南墙的过程中我突然意识到可能是我的位置有错。 总之，最后还是跟了人家的README化繁为简config成功。\n \n然后就是我不会玩的地方了.... usage我加在哪里好像都不大对呀，编译的时候总会报些错就是了。无奈我放弃了这条路，但还是心有不甘\n\n## Spotify play-button\n\n这个是个好东西的！官网教程就很好读，直接生成了frame标签方便我们添加到*.html*文件里，兴冲冲的跑去github.io里写在了index中。\n\n#### **Eureka!!!!!!**\n\n出现了hhh，但是我的主页实在是太白太干净了，有那么一个button在真实的破坏了美感，恋恋不舍的把那一行又comment掉了。  \n\n转念一想，我何不真的写一个po记一下这个代码以及分享一个playlist？\n\nSo here we are（。≖ิω≖ิ）\n\n\n代码块在这：\n\n```\n<iframe src=\"https://open.spotify.com/embed/user/spotify/playlist/37i9dQZF1DWYWddJiPzbvb&auto=1\" width=\"300\" height=\"500\" frameborder=\"0\" allowtransparency=\"true\" allow=\"encrypted-media\"></iframe>\n\n```\n(顺带提一嘴，这里非常佩服很多国内的大佬们，中华儿女真的太聪明了！找这些教程的时候我发现了可嵌套在spotify的lyrics app，[github](https://github.com/ddddxxx/LyricsX/releases) 版本以及[app store](https://itunes.apple.com/us/app/lyricsx/id1254743014?mt=12&ign-mpt=uo%3D4)都已经上架啦！非常好用！我用在自己的Spotify上玩的不亦乐乎, 感兴趣的话去支持一下呀～～）\n \n***\n\n<iframe src=\"https://open.spotify.com/embed/user/spotify/playlist/37i9dQZF1DWYWddJiPzbvb&auto=1\" width=\"760\" height=\"500\" frameborder=\"0\" allowtransparency=\"true\" allow=\"encrypted-media\"></iframe>\n\n写blog的兴趣但愿不会太早就消亡，有的时候我都很懊恼没有在大学期间就操弄起来，即使还不能叫太晚，也落后很多了，努力吧！\n<center> No more Quater-life Crisis\n\n谢谢你耐心看我碎碎念到这里, Comfort Zone歌单如名，希望你也喜欢xx\n\n<center> -折腾的7-y.\n\n\n","tags":["折腾日记"],"categories":["Self"]},{"title":"IK2200 部署小记","url":"/2018/11/09/IK2200/","content":"\n\n# 写在前面\n>  项目组 6人\n> \n>  题目： Development of a multi-threaded NAT (多线程NAT实现）\n> \n>  涉及知识：Liunx，C++，DPDK，FastClick\n> \n>  repo链接参见project页面\n\n刚准备偷个懒把写在项目repo里的wiki直接复制粘贴进来，po到站子上才发现格式这么的丑啊hhhh。\n\n其实自己并不是第一天用markdown写*.md* 呀，代码块什么的也不难分区，总之我还是老老实实的自己记录吧....\n\n## 1st Period\n\n### 拓扑图在这里\n![topology](IK2200/Capture2.png)\n\n\n第一天拿到课题，还是觉得蛮不如意的。 组里大家都想做 Meeting strict latency SLOs in key-value stores， 但无奈种种原因分配到了NAT组。（写在period 2：这时候就发现人生还是公平的，TA非常优秀负责）\n\n所有的项目好像对我来说都是一点点熟悉下来的，在写project plan的时候脑子还真是一片空，一共就三个tasks的介绍翻来覆去看了不下10遍也没有确定的进行目标。 主任务在找到合适的packet generator上发以多速率的包来实现单核NAT机器的bottleneck performance。事实上也是在寻找合适的generator这个阶段耗时最久。就project plan而言，一切都很表面，翻来覆去无非就是几个阶段的big picture，技术层面只能在进展中积累实现，对于一个（近）完全依靠虚拟机的项目，风险规避有我头疼的哈哈哈，最终我的重点还是放在了测试阶段。（写在period 2: 一个发包器的bottleneck就把我打入谷底了）\n\n因为是研究生的学校项目，测试环境也就理所应当在KTH Server的KVM上。当然我也尝试过用本地虚拟机实现，效果必然不好，但也算把配置都保留了一份。\n\n>* 本地VMware Fusion 搭建Ubuntu 16.04 两台\n>* 分配3-4个处理器 内存量力而行\n>* 安装VMware tools 在两个不同网段添加虚拟网卡\n>* 更改虚拟网卡e1000为高速网卡vmxnet3\n\n### packet generators 之旅\n\n这里我们大概寻找了6种发包软件，现除了Cisco下的[T-rex](https://trex-tgn.cisco.com/trex/doc/trex_manual.html#_introduction)还在残喘着之外，其余的都已战败。\n\n我在组里接触了[Ostinato](https://userguide.ostinato.org/Quickstart.html) 和 [Warp17](https://github.com/Juniper/warp17)两种工具，操作感都较流畅。Ostinato失利于其并不支持DPDK，与开发人员联系后得到明年更新的消息😂（坐等更新）\n\nWarp17是一个横跨多层的stateful traffic generator，应用于我们的项目比较合适，命令行CLI易懂简单，test的gui写的比较完整，提供的信息较多但在实现latency的测量方面速率影响较大，这个软件用户群体不大，但好在google group回复小哥很用心，提供的帮助也很及时，总的来说测量基本的吞吐量还是可以的。\n\n***\n\n<p align=\"center\">详细记录一下T-rex：\n\n\n最开始使用T-rex的时候，为了图方便我几乎把所有的兴趣都放在了stateless GUI上，这里我就不贴图或者gif来展示了。\n\n跟所有发包工具的gui一样，操作简单，我们可以在连接到开启trex server的机器后，先以root/user身份来acquire特定的port用来发包/收包。 后续就是新建一个profile并且在其中添加配置特定stream包的收发地址、个数/pps、协议以及特定的port range(if necessary). 那么一个flow就已经设置好了。\n\n因为收集数据的类型要求，我们必须在设置的时候要开启他的latency模式并且给不同的flow辅以不同的PG-ID，这样就会使这个的GUI所展示的dashboard十分有说头。（但也只是在demo的时候好看。。。不方便整理数据\n\n进入dashboard，除了基本的收发速度，丢包率，比较亮眼的就是它自带的latency chart。这部分最多可以设置4个窗口实时展示发包进程，一般用来观察的无非是TX，RX，AVG latency，以及latency histogram。（预期效果是在NAT的进程下比直接forward要看到更明显增加趋势的latency）\n\n但是正如我所说，gui只能用做展示，真正需要很大量数据来画图时，这个就显得非常的鸡肋了。\n\n\n> - 首先他虽然可以直接duplicate多条flow 但是需要人工手动更改port range 以及PG-ID号 以便正常计算latency  \n> - 其次根据t-rex官方指导，利用gui生成的*.yaml*文件与我们通过console进行发包时写的脚本文件格式有很大出入（gui的脚本可以通过console进行发包）  \n> - 最后就是如果我们希望flow数目增大到一定数量使用gui进行配置每条flow是极其不现实的办法\n\n\n最后我们还是回归了console本身，在研究发包脚本写法的过程中我们发现这个软件支持python脚本，经过改良，我们实现的版本代码如下：\n\n```python\nfrom trex_stl_lib.api import *\n\nclass STLS1(object):\n    \"\"\"\n    Create flow stat stream of UDP packet.\n    Can specify using tunables following params:\n      Packet length (fsize)\n      Packet group id (pg_id)\n      Packet type(pkt_type)\n      Number of streams (num_streams)\n    \"\"\"\n    def __init__ (self):\n        self.fsize = 64\n        self.pg_id = 0\n        self.num_streams = 2\n        self.dport=12\n        self.sport=1025\n        self.pps=100\n\n    def _create_stream (self):\n        size = self.fsize - 4; # HW will add 4 bytes ethernet CRC\n        pkt0=[]\n        pkt1=[]\n        for port_add in range(0,self.num_streams):\n          base_pkt0 = Ether(src = \"52:54:00:ca:f0:a4\" , dst =\"52:54:00:1e:4f:f3\") / IP(src = \"192.168.100.157\", dst = \"192.168.200.175\") / TCP(dport = self.dport+port_add, sport = 1025)\n          base_pkt1 = Ether(src = \"52:54:00:ca:f0:a4\" , dst =\"52:54:00:1e:4f:f3\") / IP(src = \"192.168.100.157\", dst = \"192.168.200.175\") / TCP(dport = 12, sport = self.dport+port_add)\n          pad0 = max(0, size - len(base_pkt0)) * 'x'\n          pad1 = max(0, size - len(base_pkt1)) * 'x'\n          pkt0.append(STLPktBuilder(pkt = base_pkt0/pad0))\n          pkt1.append(STLPktBuilder(pkt = base_pkt1/pad1))\n\n\n        streams = []\n        streams.append(STLStream(packet = pkt0[0], mode = STLTXCont(pps=1), flow_stats = STLFlowLatencyStats(pg_id = self.pg_id)))\n        streams.append(STLStream(packet = pkt0[1], mode = STLTXCont(pps=1), flow_stats = STLFlowStats(pg_id = self.pg_id+1)))\n        for pkt_num in range(0, self.num_streams):\n            streams.append(STLStream(packet = pkt0[pkt_num], mode = STLTXCont(pps=self.pps)))\n            streams.append(STLStream(packet = pkt1[pkt_num], mode = STLTXCont(pps=self.pps)))\n\n        return streams\n\n    def get_streams (self, fsize = 64, pg_id = 0,  num_streams = 1000 ,dport_num=12,sport_num=1025,pps_num=5000000, **kwargs):\n        self.fsize = fsize\n        self.pg_id = pg_id\n        self.num_streams = num_streams\n        self.dport=dport_num\n        self.sport=sport_num\n        self.pps=pps_num/(2*num_streams)\n        return self._create_stream()\n\n# dynamic load - used for trex console or simulator\ndef register():\n    return STLS1()\n\n```\n至此，我们的generator勉勉强强能运行了，但是出乎意料的是multi-threaded NAT怎么也干不过单线程，每一次的测试都在求爷爷告奶奶中让人大失所望。\n\n\n## 2nd Period（很久之后的一次总结...\n\n***\n\nTo be continued\n\n<center> -学术7-y.\n\n\n","tags":["Project"],"categories":["KTH"]},{"title":"about","url":"/about/index.html"},{"title":"category","url":"/category/index.html"},{"title":"link","url":"/link/index.html"},{"title":"project","url":"/project/index.html"},{"title":"Search","url":"/search/index.html","content":"\n"},{"title":"tag","url":"/tag/index.html"}]